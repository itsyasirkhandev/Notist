(globalThis.TURBOPACK = globalThis.TURBOPACK || []).push([typeof document === "object" ? document.currentScript : undefined, {

"[project]/node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time truthy", 1) {
    (function() {
        'use strict';
        // The Symbol used to tag the ReactElement-like types. If there is no native Symbol
        // nor polyfill, then a plain number is used for performance.
        var hasSymbol = typeof Symbol === 'function' && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for('react.element') : 0xeac7;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for('react.portal') : 0xeaca;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for('react.fragment') : 0xeacb;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for('react.strict_mode') : 0xeacc;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for('react.profiler') : 0xead2;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for('react.provider') : 0xeacd;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for('react.context') : 0xeace; // TODO: We don't use AsyncMode or ConcurrentMode anymore. They were temporary
        // (unstable) APIs that have been removed. Can we remove the symbols?
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for('react.async_mode') : 0xeacf;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for('react.concurrent_mode') : 0xeacf;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for('react.forward_ref') : 0xead0;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for('react.suspense') : 0xead1;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for('react.suspense_list') : 0xead8;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for('react.memo') : 0xead3;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for('react.lazy') : 0xead4;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for('react.block') : 0xead9;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for('react.fundamental') : 0xead5;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for('react.responder') : 0xead6;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for('react.scope') : 0xead7;
        function isValidElementType(type) {
            return typeof type === 'string' || typeof type === 'function' || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
            type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === 'object' && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
            if (typeof object === 'object' && object !== null) {
                var $$typeof = object.$$typeof;
                switch($$typeof){
                    case REACT_ELEMENT_TYPE:
                        var type = object.type;
                        switch(type){
                            case REACT_ASYNC_MODE_TYPE:
                            case REACT_CONCURRENT_MODE_TYPE:
                            case REACT_FRAGMENT_TYPE:
                            case REACT_PROFILER_TYPE:
                            case REACT_STRICT_MODE_TYPE:
                            case REACT_SUSPENSE_TYPE:
                                return type;
                            default:
                                var $$typeofType = type && type.$$typeof;
                                switch($$typeofType){
                                    case REACT_CONTEXT_TYPE:
                                    case REACT_FORWARD_REF_TYPE:
                                    case REACT_LAZY_TYPE:
                                    case REACT_MEMO_TYPE:
                                    case REACT_PROVIDER_TYPE:
                                        return $$typeofType;
                                    default:
                                        return $$typeof;
                                }
                        }
                    case REACT_PORTAL_TYPE:
                        return $$typeof;
                }
            }
            return undefined;
        } // AsyncMode is deprecated along with isAsyncMode
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false; // AsyncMode should be deprecated
        function isAsyncMode(object) {
            {
                if (!hasWarnedAboutDeprecatedIsAsyncMode) {
                    hasWarnedAboutDeprecatedIsAsyncMode = true; // Using console['warn'] to evade Babel and ESLint
                    console['warn']('The ReactIs.isAsyncMode() alias has been deprecated, ' + 'and will be removed in React 17+. Update your code to use ' + 'ReactIs.isConcurrentMode() instead. It has the exact same API.');
                }
            }
            return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
            return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
            return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
            return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
            return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
            return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
            return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
            return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
            return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
            return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
            return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
            return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
            return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
    })();
}
}}),
"[project]/node_modules/prop-types/node_modules/react-is/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
if ("TURBOPACK compile-time falsy", 0) {
    "TURBOPACK unreachable";
} else {
    module.exports = __turbopack_context__.r("[project]/node_modules/prop-types/node_modules/react-is/cjs/react-is.development.js [app-client] (ecmascript)");
}
}}),
"[project]/node_modules/next/dist/build/polyfills/object-assign.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
var assign = Object.assign.bind(Object);
module.exports = assign;
module.exports.default = module.exports; //# sourceMappingURL=object-assign.js.map
}}),
"[project]/node_modules/prop-types/lib/ReactPropTypesSecret.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ 'use strict';
var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';
module.exports = ReactPropTypesSecret;
}}),
"[project]/node_modules/prop-types/lib/has.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
}}),
"[project]/node_modules/prop-types/checkPropTypes.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
var printWarning = function() {};
if ("TURBOPACK compile-time truthy", 1) {
    var ReactPropTypesSecret = __turbopack_context__.r("[project]/node_modules/prop-types/lib/ReactPropTypesSecret.js [app-client] (ecmascript)");
    var loggedTypeFailures = {};
    var has = __turbopack_context__.r("[project]/node_modules/prop-types/lib/has.js [app-client] (ecmascript)");
    printWarning = function(text) {
        var message = 'Warning: ' + text;
        if (typeof console !== 'undefined') {
            console.error(message);
        }
        try {
            // --- Welcome to debugging React ---
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            throw new Error(message);
        } catch (x) {}
    };
}
/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */ function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
    if ("TURBOPACK compile-time truthy", 1) {
        for(var typeSpecName in typeSpecs){
            if (has(typeSpecs, typeSpecName)) {
                var error;
                // Prop type validation may throw. In case they do, we don't want to
                // fail the render phase where it didn't fail before. So we log it.
                // After these have been cleaned up, we'll let them throw.
                try {
                    // This is intentionally an invariant that gets caught. It's the same
                    // behavior as without this statement except with a better message.
                    if (typeof typeSpecs[typeSpecName] !== 'function') {
                        var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');
                        err.name = 'Invariant Violation';
                        throw err;
                    }
                    error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
                } catch (ex) {
                    error = ex;
                }
                if (error && !(error instanceof Error)) {
                    printWarning((componentName || 'React class') + ': type specification of ' + location + ' `' + typeSpecName + '` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a ' + typeof error + '. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).');
                }
                if (error instanceof Error && !(error.message in loggedTypeFailures)) {
                    // Only monitor this failure once because there tends to be a lot of the
                    // same error.
                    loggedTypeFailures[error.message] = true;
                    var stack = getStack ? getStack() : '';
                    printWarning('Failed ' + location + ' type: ' + error.message + (stack != null ? stack : ''));
                }
            }
        }
    }
}
/**
 * Resets warning cache when testing.
 *
 * @private
 */ checkPropTypes.resetWarningCache = function() {
    if (("TURBOPACK compile-time value", "development") !== 'production') {
        loggedTypeFailures = {};
    }
};
module.exports = checkPropTypes;
}}),
"[project]/node_modules/prop-types/factoryWithTypeCheckers.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
'use strict';
var ReactIs = __turbopack_context__.r("[project]/node_modules/prop-types/node_modules/react-is/index.js [app-client] (ecmascript)");
var assign = __turbopack_context__.r("[project]/node_modules/next/dist/build/polyfills/object-assign.js [app-client] (ecmascript)");
var ReactPropTypesSecret = __turbopack_context__.r("[project]/node_modules/prop-types/lib/ReactPropTypesSecret.js [app-client] (ecmascript)");
var has = __turbopack_context__.r("[project]/node_modules/prop-types/lib/has.js [app-client] (ecmascript)");
var checkPropTypes = __turbopack_context__.r("[project]/node_modules/prop-types/checkPropTypes.js [app-client] (ecmascript)");
var printWarning = function() {};
if ("TURBOPACK compile-time truthy", 1) {
    printWarning = function(text) {
        var message = 'Warning: ' + text;
        if (typeof console !== 'undefined') {
            console.error(message);
        }
        try {
            // --- Welcome to debugging React ---
            // This error was thrown as a convenience so that you can use this stack
            // to find the callsite that caused this warning to fire.
            throw new Error(message);
        } catch (x) {}
    };
}
function emptyFunctionThatReturnsNull() {
    return null;
}
module.exports = function(isValidElement, throwOnDirectAccess) {
    /* global Symbol */ var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
    var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.
    /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */ function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === 'function') {
            return iteratorFn;
        }
    }
    /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */ var ANONYMOUS = '<<anonymous>>';
    // Important!
    // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
    var ReactPropTypes = {
        array: createPrimitiveTypeChecker('array'),
        bigint: createPrimitiveTypeChecker('bigint'),
        bool: createPrimitiveTypeChecker('boolean'),
        func: createPrimitiveTypeChecker('function'),
        number: createPrimitiveTypeChecker('number'),
        object: createPrimitiveTypeChecker('object'),
        string: createPrimitiveTypeChecker('string'),
        symbol: createPrimitiveTypeChecker('symbol'),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
    };
    /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */ /*eslint-disable no-self-compare*/ function is(x, y) {
        // SameValue algorithm
        if (x === y) {
            // Steps 1-5, 7-10
            // Steps 6.b-6.e: +0 != -0
            return x !== 0 || 1 / x === 1 / y;
        } else {
            // Step 6.a: NaN == NaN
            return x !== x && y !== y;
        }
    }
    /*eslint-enable no-self-compare*/ /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */ function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === 'object' ? data : {};
        this.stack = '';
    }
    // Make `instanceof Error` still work for returned errors.
    PropTypeError.prototype = Error.prototype;
    function createChainableTypeChecker(validate) {
        if (("TURBOPACK compile-time value", "development") !== 'production') {
            var manualPropTypeCallCache = {};
            var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
            componentName = componentName || ANONYMOUS;
            propFullName = propFullName || propName;
            if (secret !== ReactPropTypesSecret) {
                if (throwOnDirectAccess) {
                    // New behavior only for users of `prop-types` package
                    var err = new Error('Calling PropTypes validators directly is not supported by the `prop-types` package. ' + 'Use `PropTypes.checkPropTypes()` to call them. ' + 'Read more at http://fb.me/use-check-prop-types');
                    err.name = 'Invariant Violation';
                    throw err;
                } else if (("TURBOPACK compile-time value", "development") !== 'production' && typeof console !== 'undefined') {
                    // Old behavior for people using React.PropTypes
                    var cacheKey = componentName + ':' + propName;
                    if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
                    manualPropTypeWarningCount < 3) {
                        printWarning('You are manually calling a React.PropTypes validation ' + 'function for the `' + propFullName + '` prop on `' + componentName + '`. This is deprecated ' + 'and will throw in the standalone `prop-types` package. ' + 'You may be seeing this warning due to a third-party PropTypes ' + 'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.');
                        manualPropTypeCallCache[cacheKey] = true;
                        manualPropTypeWarningCount++;
                    }
                }
            }
            if (props[propName] == null) {
                if (isRequired) {
                    if (props[propName] === null) {
                        return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
                    }
                    return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
                }
                return null;
            } else {
                return validate(props, propName, componentName, location, propFullName);
            }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
    }
    function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== expectedType) {
                // `propValue` being instance of, say, date/regexp, pass the 'object'
                // check, but we can offer a more precise error message here rather than
                // 'of type `object`'.
                var preciseType = getPreciseType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'), {
                    expectedType: expectedType
                });
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
    }
    function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== 'function') {
                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
            }
            var propValue = props[propName];
            if (!Array.isArray(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
            }
            for(var i = 0; i < propValue.length; i++){
                var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
                if (error instanceof Error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!isValidElement(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            if (!ReactIs.isValidElementType(propValue)) {
                var propType = getPropType(propValue);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement type.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
            if (!(props[propName] instanceof expectedClass)) {
                var expectedClassName = expectedClass.name || ANONYMOUS;
                var actualClassName = getClassName(props[propName]);
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
            if ("TURBOPACK compile-time truthy", 1) {
                if (arguments.length > 1) {
                    printWarning('Invalid arguments supplied to oneOf, expected an array, got ' + arguments.length + ' arguments. ' + 'A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z]).');
                } else {
                    printWarning('Invalid argument supplied to oneOf, expected an array.');
                }
            }
            return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            for(var i = 0; i < expectedValues.length; i++){
                if (is(propValue, expectedValues[i])) {
                    return null;
                }
            }
            var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
                var type = getPreciseType(value);
                if (type === 'symbol') {
                    return String(value);
                }
                return value;
            });
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + String(propValue) + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
        }
        return createChainableTypeChecker(validate);
    }
    function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
            if (typeof typeChecker !== 'function') {
                return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
            }
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
            }
            for(var key in propValue){
                if (has(propValue, key)) {
                    var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                    if (error instanceof Error) {
                        return error;
                    }
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
            ("TURBOPACK compile-time truthy", 1) ? printWarning('Invalid argument supplied to oneOfType, expected an instance of array.') : ("TURBOPACK unreachable", undefined);
            return emptyFunctionThatReturnsNull;
        }
        for(var i = 0; i < arrayOfTypeCheckers.length; i++){
            var checker = arrayOfTypeCheckers[i];
            if (typeof checker !== 'function') {
                printWarning('Invalid argument supplied to oneOfType. Expected an array of check functions, but ' + 'received ' + getPostfixForTypeWarning(checker) + ' at index ' + i + '.');
                return emptyFunctionThatReturnsNull;
            }
        }
        function validate(props, propName, componentName, location, propFullName) {
            var expectedTypes = [];
            for(var i = 0; i < arrayOfTypeCheckers.length; i++){
                var checker = arrayOfTypeCheckers[i];
                var checkerResult = checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
                if (checkerResult == null) {
                    return null;
                }
                if (checkerResult.data && has(checkerResult.data, 'expectedType')) {
                    expectedTypes.push(checkerResult.data.expectedType);
                }
            }
            var expectedTypesMessage = expectedTypes.length > 0 ? ', expected one of type [' + expectedTypes.join(', ') + ']' : '';
            return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`' + expectedTypesMessage + '.'));
        }
        return createChainableTypeChecker(validate);
    }
    function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
            if (!isNode(props[propName])) {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError((componentName || 'React class') + ': ' + location + ' type `' + propFullName + '.' + key + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + type + '`.');
    }
    function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
            }
            for(var key in shapeTypes){
                var checker = shapeTypes[key];
                if (typeof checker !== 'function') {
                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
                }
                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                if (error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
            var propValue = props[propName];
            var propType = getPropType(propValue);
            if (propType !== 'object') {
                return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
            }
            // We need to check all keys in case some are required but missing from props.
            var allKeys = assign({}, props[propName], shapeTypes);
            for(var key in allKeys){
                var checker = shapeTypes[key];
                if (has(shapeTypes, key) && typeof checker !== 'function') {
                    return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
                }
                if (!checker) {
                    return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' + '\nBad object: ' + JSON.stringify(props[propName], null, '  ') + '\nValid keys: ' + JSON.stringify(Object.keys(shapeTypes), null, '  '));
                }
                var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
                if (error) {
                    return error;
                }
            }
            return null;
        }
        return createChainableTypeChecker(validate);
    }
    function isNode(propValue) {
        switch(typeof propValue){
            case 'number':
            case 'string':
            case 'undefined':
                return true;
            case 'boolean':
                return !propValue;
            case 'object':
                if (Array.isArray(propValue)) {
                    return propValue.every(isNode);
                }
                if (propValue === null || isValidElement(propValue)) {
                    return true;
                }
                var iteratorFn = getIteratorFn(propValue);
                if (iteratorFn) {
                    var iterator = iteratorFn.call(propValue);
                    var step;
                    if (iteratorFn !== propValue.entries) {
                        while(!(step = iterator.next()).done){
                            if (!isNode(step.value)) {
                                return false;
                            }
                        }
                    } else {
                        // Iterator will provide entry [k,v] tuples rather than values.
                        while(!(step = iterator.next()).done){
                            var entry = step.value;
                            if (entry) {
                                if (!isNode(entry[1])) {
                                    return false;
                                }
                            }
                        }
                    }
                } else {
                    return false;
                }
                return true;
            default:
                return false;
        }
    }
    function isSymbol(propType, propValue) {
        // Native Symbol.
        if (propType === 'symbol') {
            return true;
        }
        // falsy value can't be a Symbol
        if (!propValue) {
            return false;
        }
        // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
        if (propValue['@@toStringTag'] === 'Symbol') {
            return true;
        }
        // Fallback for non-spec compliant Symbols which are polyfilled.
        if (typeof Symbol === 'function' && propValue instanceof Symbol) {
            return true;
        }
        return false;
    }
    // Equivalent of `typeof` but with special handling for array and regexp.
    function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
            return 'array';
        }
        if (propValue instanceof RegExp) {
            // Old webkits (at least until Android 4.0) return 'function' rather than
            // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
            // passes PropTypes.object.
            return 'object';
        }
        if (isSymbol(propType, propValue)) {
            return 'symbol';
        }
        return propType;
    }
    // This handles more types than `getPropType`. Only used for error messages.
    // See `createPrimitiveTypeChecker`.
    function getPreciseType(propValue) {
        if (typeof propValue === 'undefined' || propValue === null) {
            return '' + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === 'object') {
            if (propValue instanceof Date) {
                return 'date';
            } else if (propValue instanceof RegExp) {
                return 'regexp';
            }
        }
        return propType;
    }
    // Returns a string that is postfixed to a warning about an invalid type.
    // For example, "undefined" or "of type array"
    function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch(type){
            case 'array':
            case 'object':
                return 'an ' + type;
            case 'boolean':
            case 'date':
            case 'regexp':
                return 'a ' + type;
            default:
                return type;
        }
    }
    // Returns class name of the object, if any.
    function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
            return ANONYMOUS;
        }
        return propValue.constructor.name;
    }
    ReactPropTypes.checkPropTypes = checkPropTypes;
    ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
    ReactPropTypes.PropTypes = ReactPropTypes;
    return ReactPropTypes;
};
}}),
"[project]/node_modules/prop-types/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */ var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$next$2f$dist$2f$build$2f$polyfills$2f$process$2e$js__$5b$app$2d$client$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/next/dist/build/polyfills/process.js [app-client] (ecmascript)");
if ("TURBOPACK compile-time truthy", 1) {
    var ReactIs = __turbopack_context__.r("[project]/node_modules/prop-types/node_modules/react-is/index.js [app-client] (ecmascript)");
    // By explicitly using `prop-types` you are opting into new development behavior.
    // http://fb.me/prop-types-in-prod
    var throwOnDirectAccess = true;
    module.exports = __turbopack_context__.r("[project]/node_modules/prop-types/factoryWithTypeCheckers.js [app-client] (ecmascript)")(ReactIs.isElement, throwOnDirectAccess);
} else {
    "TURBOPACK unreachable";
}
}}),
"[project]/node_modules/@ckeditor/ckeditor5-react/dist/index.js [app-client] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
/*!
 * @license Copyright (c) 2003-2024, CKSource Holding sp. z o.o. All rights reserved.
 * For licensing, see LICENSE.md.
 */ !function(t, e) {
    ("TURBOPACK compile-time truthy", 1) ? module.exports = e(__turbopack_context__.r("[project]/node_modules/next/dist/compiled/react/index.js [app-client] (ecmascript)"), __turbopack_context__.r("[project]/node_modules/prop-types/index.js [app-client] (ecmascript)")) : ("TURBOPACK unreachable", undefined);
}(self, (t, e)=>(()=>{
        "use strict";
        var o = {
            949: (t)=>{
                t.exports = e;
            },
            155: (e)=>{
                e.exports = t;
            }
        }, r = {};
        function n(t) {
            var e = r[t];
            if (void 0 !== e) return e.exports;
            var a = r[t] = {
                exports: {}
            };
            return o[t](a, a.exports, n), a.exports;
        }
        n.n = (t)=>{
            var e = t && t.__esModule ? ()=>t.default : ()=>t;
            return n.d(e, {
                a: e
            }), e;
        }, n.d = (t, e)=>{
            for(var o in e)n.o(e, o) && !n.o(t, o) && Object.defineProperty(t, o, {
                enumerable: !0,
                get: e[o]
            });
        }, n.o = (t, e)=>Object.prototype.hasOwnProperty.call(t, e), n.r = (t)=>{
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
                value: "Module"
            }), Object.defineProperty(t, "__esModule", {
                value: !0
            });
        };
        var a = {};
        return (()=>{
            n.r(a), n.d(a, {
                CKEditor: ()=>l,
                CKEditorContext: ()=>c,
                useMultiRootEditor: ()=>R
            });
            var t = n(155), e = n.n(t), o = n(949), r = n.n(o);
            const i = new Array(256).fill("").map((t, e)=>("0" + e.toString(16)).slice(-2));
            const s = e().createContext("contextWatchdog");
            class c extends e().Component {
                constructor(t, e){
                    super(t, e), this.contextWatchdog = null, this.props.isLayoutReady && this._initializeContextWatchdog(this.props.config);
                }
                shouldComponentUpdate(t) {
                    return this._shouldComponentUpdate(t);
                }
                async _shouldComponentUpdate(t) {
                    return t.id !== this.props.id && (this.contextWatchdog && await this.contextWatchdog.destroy(), await this._initializeContextWatchdog(t.config)), t.isLayoutReady && !this.contextWatchdog ? (await this._initializeContextWatchdog(t.config), !0) : this.props.children !== t.children;
                }
                render() {
                    return e().createElement(s.Provider, {
                        value: this.contextWatchdog
                    }, this.props.children);
                }
                componentWillUnmount() {
                    this._destroyContext();
                }
                async _initializeContextWatchdog(t) {
                    this.contextWatchdog = new this.props.contextWatchdog(this.props.context, this.props.watchdogConfig), this.contextWatchdog.on("error", (t, e)=>{
                        this.props.onError(e.error, {
                            phase: "runtime",
                            willContextRestart: e.causesRestart
                        });
                    }), this.contextWatchdog.on("stateChange", ()=>{
                        "ready" === this.contextWatchdog.state && this.props.onReady && this.props.onReady(this.contextWatchdog.context);
                    }), await this.contextWatchdog.create(t).catch((t)=>{
                        this.props.onError(t, {
                            phase: "initialization",
                            willContextRestart: !1
                        });
                    });
                }
                async _destroyContext() {
                    this.contextWatchdog && (await this.contextWatchdog.destroy(), this.contextWatchdog = null);
                }
            }
            c.defaultProps = {
                isLayoutReady: !0,
                onError: (t, e)=>console.error(t, e)
            }, c.propTypes = {
                id: r().string,
                isLayoutReady: r().bool,
                context: r().func,
                watchdogConfig: r().object,
                config: r().object,
                onReady: r().func,
                onError: r().func
            };
            class u {
                constructor(t, e){
                    this._releaseLock = null, this._value = null, this._afterMountCallbacks = [], this._state = {
                        destroyedBeforeInitialization: !1,
                        mountingInProgress: null
                    }, this.release = function(t) {
                        let e = null;
                        return (...o)=>(e || (e = {
                                current: t(...o)
                            }), e.current);
                    }(()=>{
                        const { _releaseLock: t, _state: e, _element: o, _lifecycle: r } = this;
                        e.mountingInProgress ? e.mountingInProgress.then(()=>r.unmount({
                                element: o,
                                mountResult: this.value
                            })).catch((t)=>{
                            console.error("Semaphore unmounting error:", t);
                        }).then(t.resolve).then(()=>{
                            this._value = null;
                        }) : (e.destroyedBeforeInitialization = !0, t.resolve());
                    }), this._element = t, this._lifecycle = e, this._lock();
                }
                get value() {
                    return this._value;
                }
                unsafeSetValue(t) {
                    this._value = t, this._afterMountCallbacks.forEach((e)=>e(t)), this._afterMountCallbacks = [];
                }
                runAfterMount(t) {
                    const { _value: e, _afterMountCallbacks: o } = this;
                    e ? t(e) : o.push(t);
                }
                _lock() {
                    const { _semaphores: t } = u, { _state: e, _element: o, _lifecycle: r } = this, n = t.get(o) || Promise.resolve(null), a = function() {
                        const t = {
                            resolve: null,
                            promise: null
                        };
                        return t.promise = new Promise((e)=>{
                            t.resolve = e;
                        }), t;
                    }();
                    this._releaseLock = a;
                    const i = n.then(()=>e.destroyedBeforeInitialization ? Promise.resolve(void 0) : (e.mountingInProgress = r.mount().then((t)=>(t && this.unsafeSetValue(t), t)), e.mountingInProgress)).then(async (t)=>{
                        t && r.afterMount && await r.afterMount({
                            element: o,
                            mountResult: t
                        });
                    }).then(()=>a.promise).catch((t)=>{
                        console.error("Semaphore mounting error:", t);
                    }).then(()=>{
                        t.get(o) === i && t.delete(o);
                    });
                    t.set(o, i);
                }
            }
            u._semaphores = new Map;
            const d = "Lock from React integration (@ckeditor/ckeditor5-react)";
            class l extends e().Component {
                constructor(t){
                    super(t), this.domContainer = e().createRef(), this.editorSemaphore = null, this._checkVersion();
                }
                _checkVersion() {
                    const { CKEDITOR_VERSION: t } = window;
                    if (!t) return console.warn('Cannot find the "CKEDITOR_VERSION" in the "window" scope.');
                    const [e] = t.split(".").map(Number);
                    e >= 42 || t.startsWith("0.0.0") || console.warn("The <CKEditor> component requires using CKEditor 5 in version 42+ or nightly build.");
                }
                get _semaphoreValue() {
                    const { editorSemaphore: t } = this;
                    return t ? t.value : null;
                }
                get watchdog() {
                    const { _semaphoreValue: t } = this;
                    return t ? t.watchdog : null;
                }
                get editor() {
                    const { _semaphoreValue: t } = this;
                    return t ? t.instance : null;
                }
                shouldComponentUpdate(t) {
                    const { props: e, editorSemaphore: o } = this;
                    return t.id !== e.id || t.disableWatchdog !== e.disableWatchdog || (o && (o.runAfterMount(({ instance: o })=>{
                        this._shouldUpdateEditorData(e, t, o) && o.data.set(t.data);
                    }), "disabled" in t && o.runAfterMount(({ instance: e })=>{
                        t.disabled ? e.enableReadOnlyMode(d) : e.disableReadOnlyMode(d);
                    })), !1);
                }
                componentDidMount() {
                    this._initLifeCycleSemaphore();
                }
                componentDidUpdate() {
                    this._initLifeCycleSemaphore();
                }
                componentWillUnmount() {
                    this._unlockLifeCycleSemaphore();
                }
                _unlockLifeCycleSemaphore() {
                    this.editorSemaphore && (this.editorSemaphore.release(), this.editorSemaphore = null);
                }
                _initLifeCycleSemaphore() {
                    this._unlockLifeCycleSemaphore(), this.editorSemaphore = new u(this.domContainer.current, {
                        mount: async ()=>this._initializeEditor(),
                        afterMount: ({ mountResult: t })=>{
                            const { onReady: e } = this.props;
                            e && null !== this.domContainer.current && e(t.instance);
                        },
                        unmount: async ({ element: t, mountResult: e })=>{
                            const { onAfterDestroy: o } = this.props;
                            try {
                                await this._destroyEditor(e), t.innerHTML = "";
                            } finally{
                                o && o(e.instance);
                            }
                        }
                    });
                }
                render() {
                    return e().createElement("div", {
                        ref: this.domContainer
                    });
                }
                async _initializeEditor() {
                    if (this.props.disableWatchdog) {
                        return {
                            instance: await this._createEditor(this.domContainer.current, this._getConfig()),
                            watchdog: null
                        };
                    }
                    const t = (()=>this.context instanceof this.props.editor.ContextWatchdog ? new h(this.context) : new this.props.editor.EditorWatchdog(this.props.editor, this.props.watchdogConfig))(), e = {
                        current: 0
                    };
                    return t.setCreator(async (o, r)=>{
                        const { editorSemaphore: n } = this, { onAfterDestroy: a } = this.props;
                        e.current > 0 && a && n && n.value && n.value.instance && a(n.value.instance);
                        const i = await this._createEditor(o, r);
                        return e.current > 0 && (n.unsafeSetValue({
                            instance: i,
                            watchdog: t
                        }), setTimeout(()=>{
                            this.props.onReady && this.props.onReady(t.editor);
                        })), e.current++, i;
                    }), t.on("error", (t, { error: e, causesRestart: o })=>{
                        (this.props.onError || console.error)(e, {
                            phase: "runtime",
                            willEditorRestart: o
                        });
                    }), await t.create(this.domContainer.current, this._getConfig()).catch((t)=>{
                        (this.props.onError || console.error)(t, {
                            phase: "initialization",
                            willEditorRestart: !1
                        });
                    }), {
                        watchdog: t,
                        instance: t.editor
                    };
                }
                _createEditor(t, e) {
                    return this.props.editor.create(t, e).then((t)=>{
                        "disabled" in this.props && this.props.disabled && t.enableReadOnlyMode(d);
                        const e = t.model.document, o = t.editing.view.document;
                        return e.on("change:data", (e)=>{
                            this.props.onChange && this.props.onChange(e, t);
                        }), o.on("focus", (e)=>{
                            this.props.onFocus && this.props.onFocus(e, t);
                        }), o.on("blur", (e)=>{
                            this.props.onBlur && this.props.onBlur(e, t);
                        }), t;
                    });
                }
                async _destroyEditor(t) {
                    const { watchdog: e, instance: o } = t;
                    return new Promise((t, r)=>{
                        setTimeout(async ()=>{
                            try {
                                if (e) return await e.destroy(), t();
                                if (o) return await o.destroy(), t();
                                t();
                            } catch (t) {
                                console.error(t), r(t);
                            }
                        });
                    });
                }
                _shouldUpdateEditorData(t, e, o) {
                    return t.data !== e.data && o.data.get() !== e.data;
                }
                _getConfig() {
                    const t = this.props.config || {};
                    return this.props.data && t.initialData && console.warn("Editor data should be provided either using `config.initialData` or `content` property. The config value takes precedence over `content` property and will be used when both are specified."), {
                        ...t,
                        initialData: t.initialData || this.props.data || ""
                    };
                }
            }
            l.contextType = s, l.propTypes = {
                editor: r().func.isRequired,
                data: r().string,
                config: r().object,
                disableWatchdog: r().bool,
                watchdogConfig: r().object,
                onChange: r().func,
                onReady: r().func,
                onFocus: r().func,
                onBlur: r().func,
                onError: r().func,
                disabled: r().bool,
                id: r().any
            };
            class h {
                constructor(t){
                    this._contextWatchdog = t, this._id = function() {
                        const t = 4294967296 * Math.random() >>> 0, e = 4294967296 * Math.random() >>> 0, o = 4294967296 * Math.random() >>> 0, r = 4294967296 * Math.random() >>> 0;
                        return "e" + i[255 & t] + i[t >> 8 & 255] + i[t >> 16 & 255] + i[t >> 24 & 255] + i[255 & e] + i[e >> 8 & 255] + i[e >> 16 & 255] + i[e >> 24 & 255] + i[255 & o] + i[o >> 8 & 255] + i[o >> 16 & 255] + i[o >> 24 & 255] + i[255 & r] + i[r >> 8 & 255] + i[r >> 16 & 255] + i[r >> 24 & 255];
                    }();
                }
                setCreator(t) {
                    this._creator = t;
                }
                create(t, e) {
                    return this._contextWatchdog.add({
                        sourceElementOrData: t,
                        config: e,
                        creator: this._creator,
                        id: this._id,
                        type: "editor"
                    });
                }
                on(t, e) {
                    this._contextWatchdog.on("itemError", (t, { itemId: o, error: r })=>{
                        o === this._id && e(null, {
                            error: r,
                            causesRestart: void 0
                        });
                    });
                }
                destroy() {
                    return "ready" === this._contextWatchdog.state ? this._contextWatchdog.remove(this._id) : Promise.resolve();
                }
                get editor() {
                    return this._contextWatchdog.getItem(this._id);
                }
            }
            function p(...t) {
                return (e)=>{
                    t.forEach((t)=>{
                        "function" == typeof t ? t(e) : null != t && (t.current = e);
                    });
                };
            }
            function f(t, e) {
                for (const t of Object.getOwnPropertyNames(e))delete e[t];
                for (const [o, r] of Object.entries(t))r !== e && "prototype" !== o && "__proto__" !== o && (e[o] = r);
                return e;
            }
            const m = (e)=>{
                const o = (0, t.useRef)();
                return o.current = e, (0, t.useCallback)((...t)=>o.current(...t), []);
            };
            function g(t, e) {
                return e.length = 0, e.push(...t), e;
            }
            const y = (e, o, r)=>{
                ((e, o)=>{
                    const r = (0, t.useRef)(null);
                    ((t, e)=>{
                        if (t === e) return !0;
                        if (!t || !e) return !1;
                        for(let o = 0; o < t.length; ++o)if (t[o] !== e[o]) return !1;
                        return !0;
                    })(r.current, o) || (r.current = [
                        ...o
                    ], e());
                })(()=>{
                    e && e.runAfterMount(o);
                }, [
                    e,
                    ...r
                ]);
            }, b = "Lock from React integration (@ckeditor/ckeditor5-react)", w = (0, t.memo)((0, t.forwardRef)(({ id: o, semaphore: r, rootName: n }, a)=>{
                const i = (0, t.useRef)(null);
                return (0, t.useEffect)(()=>{
                    let t, e;
                    return r.runAfterMount(({ instance: o })=>{
                        i.current && (e = o, t = o.ui.view.createEditable(n, i.current), o.ui.addEditable(t), o.editing.view.forceRender());
                    }), ()=>{
                        t && i.current && e && "destroyed" !== e.state && e.ui.removeEditable(t);
                    };
                }, [
                    r.revision
                ]), e().createElement("div", {
                    key: r.revision,
                    id: o,
                    ref: p(a, i)
                });
            }));
            w.displayName = "EditorEditable";
            const _ = (0, t.forwardRef)(({ editor: o }, r)=>{
                const n = (0, t.useRef)(null);
                return (0, t.useEffect)(()=>{
                    const t = n.current;
                    if (!o || !t) return;
                    const e = o.ui.view.toolbar.element;
                    return t && t.appendChild(e), ()=>{
                        t && t.removeChild(e);
                    };
                }, [
                    o && o.id
                ]), e().createElement("div", {
                    ref: p(n, r)
                });
            });
            _.displayName = "EditorToolbarWrapper";
            const R = (o)=>{
                const r = (0, t.useRef)(o.semaphoreElement || null), n = (()=>{
                    const e = (0, t.useRef)(null), [o, r] = (0, t.useState)(()=>Date.now()), n = ()=>{
                        r(Date.now());
                    }, a = (t = !0)=>{
                        e.current && (e.current.release(), e.current = null), t && r(Date.now());
                    }, i = (t)=>{
                        e.current && e.current.runAfterMount(t);
                    };
                    return {
                        get current () {
                            return e.current;
                        },
                        revision: o,
                        createAttributeRef: (t)=>({
                                get current () {
                                    return e.current && e.current.value ? e.current.value[t] : null;
                                }
                            }),
                        unsafeSetValue: (t)=>{
                            var o;
                            null === (o = e.current) || void 0 === o || o.unsafeSetValue(t), n();
                        },
                        release: a,
                        replace: (t)=>{
                            a(!1), e.current = t(), n(), i(n);
                        },
                        runAfterMount: i
                    };
                })(), a = {
                    watchdog: n.createAttributeRef("watchdog"),
                    instance: n.createAttributeRef("instance")
                }, i = (0, t.useContext)(s), [c, d] = (0, t.useState)(()=>Object.keys(o.data)), [l, p] = (0, t.useState)({
                    ...o.data
                }), [R, C] = (0, t.useState)({
                    ...o.rootsAttributes
                }), v = (0, t.useRef)(!0);
                (0, t.useEffect)(()=>{
                    const t = r.current;
                    if (t && !1 !== o.isLayoutReady) return n.replace(()=>new u(t, {
                            mount: O,
                            afterMount: ({ mountResult: t })=>{
                                const { onReady: e } = o;
                                e && null !== r.current && e(t.instance);
                            },
                            unmount: async ({ element: t, mountResult: e })=>{
                                const { onAfterDestroy: r } = o;
                                try {
                                    await M(e), t.innerHTML = "";
                                } finally{
                                    r && r(e.instance);
                                }
                            }
                        })), ()=>{
                        n.release(!1);
                    };
                }, [
                    o.id,
                    o.isLayoutReady
                ]);
                const E = ()=>{
                    const t = o.config || {};
                    return o.data && t.initialData && console.warn("Editor data should be provided either using `config.initialData` or `data` property. The config value takes precedence over `data` property and will be used when both are specified."), {
                        ...t,
                        rootsAttributes: R
                    };
                }, x = m((t, e)=>{
                    const r = t.model.document;
                    if (!o.disableTwoWayDataBinding) {
                        const e = {}, o = {};
                        r.differ.getChanges().forEach((o)=>{
                            let r;
                            if (r = "insert" == o.type || "remove" == o.type ? o.position.root : o.range.root, !r.isAttached()) return;
                            const { rootName: n } = r;
                            e[n] = t.getData({
                                rootName: n
                            });
                        }), r.differ.getChangedRoots().forEach((r)=>{
                            if (r.state) return void (void 0 !== e[r.name] && delete e[r.name]);
                            const n = r.name;
                            o[n] = t.getRootAttributes(n);
                        }), Object.keys(e).length && p((t)=>({
                                ...t,
                                ...e
                            })), Object.keys(o).length && C((t)=>({
                                ...t,
                                ...o
                            }));
                    }
                    o.onChange && o.onChange(e, t);
                }), W = m((t, e, r)=>{
                    const n = r.rootName;
                    o.disableTwoWayDataBinding || (p((e)=>({
                            ...e,
                            [n]: t.getData({
                                rootName: n
                            })
                        })), C((e)=>({
                            ...e,
                            [n]: t.getRootAttributes(n)
                        }))), d((t)=>{
                        return e = [
                            ...t,
                            r.rootName
                        ], Array.from(new Set(e));
                        "TURBOPACK unreachable";
                        var e;
                    });
                }), k = m((t, e, r)=>{
                    const n = r.rootName;
                    o.disableTwoWayDataBinding || (p((t)=>{
                        const { [n]: e, ...o } = t;
                        return {
                            ...o
                        };
                    }), C((t)=>{
                        const { [n]: e, ...o } = t;
                        return {
                            ...o
                        };
                    })), d((t)=>t.filter((t)=>t !== n));
                }), S = m((t, e)=>(f({
                        ...o.rootsAttributes
                    }, R), f({
                        ...o.data
                    }, l), g(Object.keys(o.data), c), o.editor.create(t, e).then((t)=>{
                        const e = t.getFullData();
                        f({
                            ...e
                        }, l), f({
                            ...t.getRootsAttributes()
                        }, R), g(Object.keys(e), c), o.disabled && t.enableReadOnlyMode(b);
                        const r = t.model.document, n = t.editing.view.document;
                        return r.on("change:data", (e)=>x(t, e)), t.on("addRoot", (e, o)=>W(t, e, o)), t.on("detachRoot", (e, o)=>k(t, e, o)), n.on("focus", (e)=>{
                            o.onFocus && o.onFocus(e, t);
                        }), n.on("blur", (e)=>{
                            o.onBlur && o.onBlur(e, t);
                        }), t;
                    }))), M = (t)=>{
                    const { watchdog: e, instance: o } = t;
                    return new Promise((t, r)=>{
                        setTimeout(async ()=>{
                            try {
                                if (e) return await e.destroy(), t();
                                if (o) return await o.destroy(), t();
                                t();
                            } catch (t) {
                                console.error(t), r(t);
                            }
                        });
                    });
                }, O = async ()=>{
                    if (o.disableWatchdog) {
                        return {
                            instance: await S(o.data, E()),
                            watchdog: null
                        };
                    }
                    const t = i instanceof o.editor.ContextWatchdog ? new h(i) : new o.editor.EditorWatchdog(o.editor, o.watchdogConfig), e = {
                        current: 0
                    };
                    return t.setCreator(async (r, i)=>{
                        const { onAfterDestroy: s } = o;
                        e.current > 0 && s && a.instance.current && s(a.instance.current);
                        const c = await S(r, i);
                        return e.current > 0 && (n.unsafeSetValue({
                            instance: c,
                            watchdog: t
                        }), setTimeout(()=>{
                            o.onReady && o.onReady(t.editor);
                        })), e.current++, c;
                    }), t.on("error", (t, { error: e, causesRestart: r })=>{
                        (o.onError || console.error)(e, {
                            phase: "runtime",
                            willEditorRestart: r
                        });
                    }), await t.create(l, E()).catch((t)=>{
                        throw (o.onError || console.error)(t, {
                            phase: "initialization",
                            willEditorRestart: !1
                        }), t;
                    }), {
                        watchdog: t,
                        instance: t.editor
                    };
                }, A = (0, t.useCallback)((t)=>{
                    n.runAfterMount(()=>{
                        v.current = !0, p(t);
                    });
                }, [
                    p
                ]), D = (0, t.useCallback)((t)=>{
                    n.runAfterMount(()=>{
                        v.current = !0, C(t);
                    });
                }, [
                    C
                ]), j = e().createElement(_, {
                    ref: r,
                    editor: a.instance.current
                });
                y(n.current, ({ instance: t })=>{
                    o.disabled ? t.enableReadOnlyMode(b) : t.disableReadOnlyMode(b);
                }, [
                    o.disabled
                ]), y(n.current, ({ instance: t })=>{
                    if (v.current) {
                        v.current = !1;
                        const e = Object.keys(l), o = Object.keys(R);
                        if (!e.every((t)=>o.includes(t))) throw console.error("`data` and `attributes` objects must have the same keys (roots)."), new Error("`data` and `attributes` objects must have the same keys (roots).");
                        const r = t.getFullData(), n = t.getRootsAttributes(), { addedKeys: a, removedKeys: i } = ((t, e)=>{
                            const o = Object.keys(t), r = Object.keys(e);
                            return {
                                addedKeys: r.filter((t)=>!o.includes(t)),
                                removedKeys: o.filter((t)=>!r.includes(t))
                            };
                        })(r, l || {}), s = e.some((t)=>void 0 !== r[t] && JSON.stringify(r[t]) !== JSON.stringify(l[t])), c = o.filter((t)=>JSON.stringify(n[t]) !== JSON.stringify(R[t])), u = (e)=>{
                            e.forEach((e)=>{
                                t.addRoot(e, {
                                    data: l[e] || "",
                                    attributes: (null == R ? void 0 : R[e]) || {},
                                    isUndoable: !0
                                });
                            });
                        }, d = (e)=>{
                            e.forEach((e)=>{
                                t.detachRoot(e, !0);
                            });
                        }, h = ()=>{
                            t.data.set(l, {
                                suppressErrorInCollaboration: !0
                            });
                        }, p = (e, o)=>{
                            o.forEach((o)=>{
                                Object.keys(R[o]).forEach((e)=>{
                                    t.registerRootAttribute(e);
                                }), e.clearAttributes(t.model.document.getRoot(o)), e.setAttributes(R[o], t.model.document.getRoot(o));
                            });
                        };
                        setTimeout(()=>{
                            t.model.change((t)=>{
                                u(a), d(i), s && h(), c.length && p(t, c);
                            });
                        });
                    }
                }, [
                    l,
                    R
                ]);
                const T = c.map((t)=>e().createElement(w, {
                        key: t,
                        id: t,
                        rootName: t,
                        semaphore: n
                    }));
                return {
                    editor: a.instance.current,
                    editableElements: T,
                    toolbarElement: j,
                    data: l,
                    setData: A,
                    attributes: R,
                    setAttributes: D
                };
            };
        })(), a;
    })()); //# sourceMappingURL=index.js.map
}}),
}]);

//# sourceMappingURL=node_modules_56e450e2._.js.map